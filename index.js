// Generated by CoffeeScript 1.6.3
/*
rsmq

A Really Simple Message Queue based on Redis

The MIT License (MIT)

Copyright © 2013 Patrick Liess, http://www.tcs.de

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/


(function() {
  var RedisInst, RedisSMQ, crypto, eventEmitter, events, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  crypto = require("crypto");

  _ = require("underscore");

  RedisInst = require("redis");

  events = require("events");

  eventEmitter = new events.EventEmitter();

  RedisSMQ = (function() {
    function RedisSMQ(options) {
      var opts, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      this._initErrors = __bind(this._initErrors, this);
      this._handleError = __bind(this._handleError, this);
      this.sendMessage = __bind(this.sendMessage, this);
      this._receiveMessage = __bind(this._receiveMessage, this);
      this.receiveMessage = __bind(this.receiveMessage, this);
      this.listQueues = __bind(this.listQueues, this);
      this.getQueueAttributes = __bind(this.getQueueAttributes, this);
      this.deleteQueue = __bind(this.deleteQueue, this);
      this.deleteMessage = __bind(this.deleteMessage, this);
      this.createQueue = __bind(this.createQueue, this);
      this._changeMessageVisibility = __bind(this._changeMessageVisibility, this);
      this.changeMessageVisibility = __bind(this.changeMessageVisibility, this);
      this._getQueue = __bind(this._getQueue, this);
      opts = _.extend({
        host: "127.0.0.1",
        port: 6379,
        client: null,
        ns: "rsmq"
      }, options);
      this.redisns = opts.ns + ":";
      if ((typeof opt !== "undefined" && opt !== null ? (_ref = opt.client) != null ? (_ref1 = _ref.constructor) != null ? _ref1.name : void 0 : void 0 : void 0) === "RedisClient") {
        this.redis = opt.client;
      } else {
        this.redis = RedisInst.createClient(opts.port, opts.host);
      }
      this.initScript();
      this._initErrors();
    }

    RedisSMQ.prototype._getQueue = function(qname, uid, cb) {
      var mc,
        _this = this;
      mc = [["hmget", "" + this.redisns + qname + ":Q", "vt", "delay", "maxsize"], ["time"]];
      this.redis.multi(mc).exec(function(err, resp) {
        var ms, q, ts;
        if (err) {
          _this._handleError(cb, err);
          return;
        }
        if (resp[0][0] === null || resp[0][1] === null || resp[0][2] === null) {
          _this._handleError(cb, "queueNotFound");
          return;
        }
        ms = _this._formatZeroPad(Number(resp[1][1]), 6);
        ts = Number(resp[1][0] + ms.toString(10).slice(0, 3));
        q = {
          vt: parseInt(resp[0][0], 10),
          delay: parseInt(resp[0][1], 10),
          maxsize: parseInt(resp[0][2], 10),
          ts: ts
        };
        if (uid) {
          uid = _this._makeid(22);
          q.uid = Number(resp[1][0] + ms).toString(36) + uid;
        }
        cb(null, q);
      });
    };

    RedisSMQ.prototype.changeMessageVisibility = function(options, cb) {
      var _this = this;
      if (this._validate(options, ["qname", "id", "vt"], cb) === false) {
        return;
      }
      this._getQueue(options.qname, false, function(err, q) {
        if (err) {
          _this._handleError(cb, err);
          return;
        }
        if (_this.changeMessageVisibility_sha1) {
          _this._changeMessageVisibility(options, q, cb);
          return;
        }
        changeMessageVisibility.on('changeMessageVisibility', function() {
          _this._changeMessageVisibility(options, q, cb);
        });
      });
    };

    RedisSMQ.prototype._changeMessageVisibility = function(options, q, cb) {
      var _this = this;
      this.redis.evalsha(this.changeMessageVisibility_sha1, 3, "" + this.redisns + options.qname, options.id, q.ts + options.vt * 1000, function(err, resp) {
        if (err) {
          _handleError(cb, err);
          return;
        }
        cb(null, resp);
      });
    };

    RedisSMQ.prototype.createQueue = function(options, cb) {
      var _ref, _ref1, _ref2,
        _this = this;
      options.vt = (_ref = options.vt) != null ? _ref : 30;
      options.delay = (_ref1 = options.delay) != null ? _ref1 : 0;
      options.maxsize = (_ref2 = options.maxsize) != null ? _ref2 : 65536;
      if (this._validate(options, ["qname", "vt", "delay", "maxsize"], cb) === false) {
        return;
      }
      this.redis.time(function(err, resp) {
        var mc;
        if (err) {
          _this._handleError(cb, err);
          return;
        }
        mc = [["hsetnx", "" + _this.redisns + options.qname + ":Q", "vt", options.vt], ["hsetnx", "" + _this.redisns + options.qname + ":Q", "delay", options.delay], ["hsetnx", "" + _this.redisns + options.qname + ":Q", "maxsize", options.maxsize], ["hsetnx", "" + _this.redisns + options.qname + ":Q", "created", resp[0]], ["hsetnx", "" + _this.redisns + options.qname + ":Q", "modified", resp[0]]];
        _this.redis.multi(mc).exec(function(err, resp) {
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          if (resp[0] === 0) {
            _this._handleError(cb, "queueExists");
            return;
          }
          _this.redis.sadd("" + _this.redisns + "QUEUES", options.qname, function(err, resp) {
            if (err) {
              _handleError(cb, err);
              return;
            }
            cb(null, 1);
          });
        });
      });
    };

    RedisSMQ.prototype.deleteMessage = function(options, cb) {
      var key, mc,
        _this = this;
      if (this._validate(options, ["qname", "id"], cb) === false) {
        return;
      }
      key = "" + this.redisns + options.qname;
      mc = [["zrem", key, options.id], ["hdel", "" + key + ":Q", "" + options.id, "" + options.id + ":rc", "" + options.id + ":fr"]];
      this.redis.multi(mc).exec(function(err, resp) {
        if (err) {
          _this._handleError(cb, err);
          return;
        }
        if (resp[0] === 1 && resp[1] > 0) {
          cb(null, 1);
        } else {
          cb(null, 0);
        }
      });
    };

    RedisSMQ.prototype.deleteQueue = function(options, cb) {
      var key, mc,
        _this = this;
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      key = "" + this.redisns + options.qname;
      mc = [["del", "" + key + ":Q"], ["del", key], ["srem", "" + this.redisns + "QUEUES", options.qname]];
      this.redis.multi(mc).exec(function(err, resp) {
        if (err) {
          _this._handleError(cb, err);
          return;
        }
        if (resp[0] === 0) {
          _this._handleError(cb, "queueNotFound");
          return;
        }
        cb(null, 1);
      });
    };

    RedisSMQ.prototype.getQueueAttributes = function(options, cb) {
      var key,
        _this = this;
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      key = "" + this.redisns + options.qname;
      this.redis.time(function(err, resp) {
        var mc;
        if (err) {
          _this._handleError(cb, err);
          return;
        }
        mc = [["hmget", "" + key + ":Q", "vt", "delay", "maxsize", "totalrecv", "totalsent", "created", "modified"], ["zcard", key], ["zcount", key, "-inf", resp[0] + "000"]];
        _this.redis.multi(mc).exec(function(err, resp) {
          var o;
          if (err) {
            _this._handleError(cb, err);
            return;
          }
          if (resp[0][0] === null) {
            _this._handleError(cb, "queueNotFound");
            return;
          }
          o = {
            vt: parseInt(resp[0][0], 10),
            delay: parseInt(resp[0][1], 10),
            maxsize: parseInt(resp[0][2], 10),
            totalrecv: parseInt(resp[0][3], 10),
            totalsent: parseInt(resp[0][4], 10),
            created: parseInt(resp[0][5], 10),
            modified: parseInt(resp[0][6], 10),
            msgs: resp[1],
            hiddenmsgs: resp[2]
          };
          cb(null, o);
        });
      });
    };

    RedisSMQ.prototype.initScript = function(cb) {
      var script_changeMessageVisibility, script_receiveMessage,
        _this = this;
      script_receiveMessage = 'local msg = redis.call("ZRANGEBYSCORE", KEYS[1], "-inf", KEYS[2], "LIMIT", "0", "1")\
			if #msg == 0 then\
				return {}\
			end\
			redis.call("ZADD", KEYS[1], KEYS[3], msg[1])\
			redis.call("HINCRBY", KEYS[1] .. ":Q", "totalrecv", 1)\
			local mbody = redis.call("HGET", KEYS[1] .. ":Q", msg[1])\
			local rc = redis.call("HINCRBY", KEYS[1] .. ":Q", msg[1] .. ":rc", 1)\
			local o = {msg[1], mbody, rc}\
			if rc==1 then\
				redis.call("HSET", KEYS[1] .. ":Q", msg[1] .. ":fr", KEYS[2])\
				table.insert(o, KEYS[2])\
			else			\
				local fr = redis.call("HGET", KEYS[1] .. ":Q", msg[1] .. ":fr")\
				table.insert(o, fr)\
			end\
			return o';
      script_changeMessageVisibility = 'local msg = redis.call("ZSCORE", KEYS[1], KEYS[2])\
			if not msg then\
				return 0\
			end\
			redis.call("ZADD", KEYS[1], KEYS[3], KEYS[2])\
			return 1';
      this.redis.script("load", script_receiveMessage, function(err, resp) {
        _this.receiveMessage_sha1 = resp;
        eventEmitter.emit('receiveMessage', 'ready');
      });
      this.redis.script("load", script_changeMessageVisibility, function(err, resp) {
        _this.changeMessageVisibility_sha1 = resp;
        eventEmitter.emit('changeMessageVisibility', 'ready');
      });
    };

    RedisSMQ.prototype.listQueues = function(cb) {
      var _this = this;
      this.redis.smembers("" + this.redisns + "QUEUES", function(err, resp) {
        if (err) {
          _this._handleError(cb, err);
          return;
        }
        cb(null, resp);
      });
    };

    RedisSMQ.prototype.receiveMessage = function(options, cb) {
      var _this = this;
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      this._getQueue(options.qname, false, function(err, q) {
        var _ref;
        if (err) {
          _this._handleError(cb, err);
          return;
        }
        options.vt = (_ref = options.vt) != null ? _ref : q.vt;
        if (_this._validate(options, ["vt"], cb) === false) {
          return;
        }
        if (_this.receiveMessage_sha1) {
          _this._receiveMessage(options, q, cb);
          return;
        }
        eventEmitter.on('receiveMessage', function() {
          _this._receiveMessage(options, q, cb);
        });
      });
    };

    RedisSMQ.prototype._receiveMessage = function(options, q, cb) {
      var _this = this;
      this.redis.evalsha(this.receiveMessage_sha1, 3, "" + this.redisns + options.qname, q.ts, q.ts + options.vt * 1000, function(err, resp) {
        var o;
        if (err) {
          _handleError(cb, err);
          return;
        }
        if (!resp.length) {
          cb(null, {});
          return;
        }
        o = {
          id: resp[0],
          message: resp[1],
          rc: resp[2],
          fr: Number(resp[3]),
          sent: parseInt(parseInt(resp[0].slice(0, 10), 36) / 1000)
        };
        cb(null, o);
      });
    };

    RedisSMQ.prototype.sendMessage = function(options, cb) {
      var _this = this;
      if (this._validate(options, ["qname"], cb) === false) {
        return;
      }
      this._getQueue(options.qname, true, function(err, q) {
        var mc, _ref;
        if (err) {
          _this._handleError(cb, err);
          return;
        }
        options.delay = (_ref = options.delay) != null ? _ref : q.delay;
        if (_this._validate(options, ["delay"], cb) === false) {
          return;
        }
        if (typeof options.message !== "string") {
          _this._handleError(cb, "messageNotString");
          return;
        }
        if (options.message.length > q.maxsize) {
          _this._handleError(cb, "messageTooLong");
          return;
        }
        mc = [["zadd", "" + _this.redisns + options.qname, q.ts + options.delay * 1000, q.uid], ["hset", "" + _this.redisns + options.qname + ":Q", q.uid, options.message], ["hincrby", "" + _this.redisns + options.qname + ":Q", "totalsent", 1]];
        _this.redis.multi(mc).exec(function(err, resp) {
          if (err) {
            _handleError(cb, err);
            return;
          }
          cb(null, q.uid);
        });
      });
    };

    RedisSMQ.prototype._formatZeroPad = function(num, count) {
      return ((Math.pow(10, count) + num) + "").substr(1);
    };

    RedisSMQ.prototype._handleError = function(cb, err, data) {
      var _err, _ref;
      if (data == null) {
        data = {};
      }
      if (_.isString(err)) {
        _err = new Error();
        _err.name = err;
        _err.message = ((_ref = this._ERRORS) != null ? typeof _ref[err] === "function" ? _ref[err](data) : void 0 : void 0) || "unkown";
      } else {
        _err = err;
      }
      cb(_err);
    };

    RedisSMQ.prototype._initErrors = function() {
      var key, msg, _ref;
      this._ERRORS = {};
      _ref = this.ERRORS;
      for (key in _ref) {
        msg = _ref[key];
        this._ERRORS[key] = _.template(msg);
      }
    };

    RedisSMQ.prototype._makeid = function(len) {
      var i, possible, text, _i;
      text = "";
      possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
      }
      return text;
    };

    RedisSMQ.prototype._VALID = {
      qname: /^([a-zA-Z0-9_-]){1,80}$/,
      id: /^([a-zA-Z0-9:]){32}$/
    };

    RedisSMQ.prototype._validate = function(o, items, cb) {
      var item, _i, _len;
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        switch (item) {
          case "qname":
          case "id":
            if (!o[item]) {
              this._handleError(cb, "missingParameter", {
                item: item
              });
              return false;
            }
            o[item] = o[item].toString();
            if (!this._VALID[item].test(o[item])) {
              this._handleError(cb, "invalidFormat", {
                item: item
              });
              return false;
            }
            break;
          case "vt":
          case "delay":
            o[item] = parseInt(o[item], 10);
            if (_.isNaN(o[item]) || !_.isNumber(o[item]) || o[item] < 0 || o[item] > 9999999) {
              this._handleError(cb, "invalidValue", {
                item: item,
                min: 0,
                max: 9999999
              });
              return false;
            }
            break;
          case "maxsize":
            o[item] = parseInt(o[item], 10);
            if (_.isNaN(o[item]) || !_.isNumber(o[item]) || o[item] < 1024 || o[item] > 65536) {
              this._handleError(cb, "invalidValue", {
                item: item,
                min: 1024,
                max: 65536
              });
              return false;
            }
        }
      }
      return o;
    };

    RedisSMQ.prototype.ERRORS = {
      "missingParameter": "No <%= item %> supplied",
      "invalidFormat": "Invalid <%= item %> format",
      "invalidValue": "<%= item %> must be between <%= min %> and <%= max %>",
      "messageNotString": "Message must be a string",
      "messageTooLong": "Message too long",
      "queueNotFound": "Queue not found",
      "queueExists": "Queue exists"
    };

    return RedisSMQ;

  })();

  module.exports = RedisSMQ;

}).call(this);
